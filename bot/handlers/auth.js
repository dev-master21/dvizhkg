import { Markup } from 'telegraf';
import { pool } from '../services/database.js';
import crypto from 'crypto';

// Store auth sessions temporarily
const authSessions = new Map();

export const handleStart = async (ctx) => {
  try {
    const startParam = ctx.message.text.split(' ')[1];
    
    if (startParam && startParam.startsWith('auth_')) {
      // This is an auth request from website
      const sessionId = startParam.replace('auth_', '');
      
      // Check if session exists and is valid
      const [sessions] = await pool.execute(
        'SELECT * FROM auth_sessions WHERE session_id = ? AND expires_at > NOW()',
        [sessionId]
      );
      
      if (sessions.length === 0) {
        return ctx.reply(
          '‚ùå –°—Å—ã–ª–∫–∞ –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ –∏–ª–∏ –∏—Å—Ç–µ–∫–ª–∞.\n\n' +
          'üîÑ –í–µ—Ä–Ω–∏—Ç–µ—Å—å –Ω–∞ —Å–∞–π—Ç –∏ –Ω–∞—á–Ω–∏—Ç–µ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é –∑–∞–Ω–æ–≤–æ.'
        );
      }
      
      // Request contact
      await ctx.reply(
        'üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ DVIZH BISHKEK!\n\n' +
        'üì± –î–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –Ω–∞ —Å–∞–π—Ç–µ –ø–æ–¥–µ–ª–∏—Ç–µ—Å—å —Å–≤–æ–∏–º –∫–æ–Ω—Ç–∞–∫—Ç–æ–º:',
        Markup.keyboard([
          [Markup.button.contactRequest('üì± –ü–æ–¥–µ–ª–∏—Ç—å—Å—è –∫–æ–Ω—Ç–∞–∫—Ç–æ–º')]
        ]).resize()
      );
      
      // Store session
      authSessions.set(ctx.from.id, {
        sessionId,
        timestamp: Date.now()
      });
    } else {
      // Regular start
      await ctx.reply(
        'üî• –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ DVIZH BISHKEK BOT! üî•\n\n' +
        '–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã:\n' +
        '/top - –¢–æ–ø –¥–≤–∏–∂–Ω—è–∫–æ–≤\n' +
        '/stats - –¢–≤–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞\n' +
        '/event - –ë–ª–∏–∂–∞–π—à–∏–µ —Å–æ–±—ã—Ç–∏—è\n' +
        '/help - –ü–æ–º–æ—â—å'
      );
    }
  } catch (error) {
    console.error('Start command error:', error);
  }
};

export const handleContact = async (ctx) => {
  try {
    if (!ctx.message.contact) return;
    
    const { phone_number, user_id } = ctx.message.contact;
    
    // Check if this user has auth session
    const session = authSessions.get(ctx.from.id);
    if (!session) {
      return ctx.reply('‚ùå –°–µ—Å—Å–∏—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å —Å–∞–π—Ç–∞.');
    }
    
    // Remove keyboard
    await ctx.reply('‚úÖ –ö–æ–Ω—Ç–∞–∫—Ç –ø–æ–ª—É—á–µ–Ω! –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å–∫–∏...', Markup.removeKeyboard());
    
    // Check subscriptions
    const groupId = process.env.TELEGRAM_GROUP_ID;
    const chatId = process.env.TELEGRAM_CHAT_ID;
    
    const [isGroupMember, isChatMember] = await Promise.all([
      checkChatMember(ctx, groupId, user_id),
      checkChatMember(ctx, chatId, user_id)
    ]);
    
    if (!isGroupMember || !isChatMember) {
      // Show subscription buttons
      const keyboard = [];
      
      if (!isGroupMember) {
        keyboard.push([
          Markup.button.url('üì¢ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –≥—Ä—É–ø–ø—É', process.env.TELEGRAM_GROUP_LINK)
        ]);
      }
      
      if (!isChatMember) {
        keyboard.push([
          Markup.button.url('üí¨ –í—Å—Ç—É–ø–∏—Ç—å –≤ —á–∞—Ç', process.env.TELEGRAM_CHAT_LINK)
        ]);
      }
      
      keyboard.push([
        Markup.button.callback('‚úÖ –Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è', 'check_subscription')
      ]);
      
      await ctx.reply(
        '‚ùó –î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–∞–π—Ç—É –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ:\n\n' +
        (!isGroupMember ? 'üì¢ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –≥—Ä—É–ø–ø—É DVIZH\n' : '') +
        (!isChatMember ? 'üí¨ –í—Å—Ç—É–ø–∏—Ç—å –≤ —á–∞—Ç DVIZH\n' : '') +
        '\n–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É "–Ø –ø–æ–¥–ø–∏—Å–∞–ª—Å—è"',
        Markup.inlineKeyboard(keyboard)
      );
      
      // Store phone number for later
      session.phoneNumber = phone_number;
      authSessions.set(ctx.from.id, session);
    } else {
      // User is subscribed, create auth tokens
      await createAuthTokens(ctx, phone_number, session.sessionId);
    }
  } catch (error) {
    console.error('Contact handler error:', error);
    ctx.reply('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
  }
};

export const handleCheckSubscription = async (ctx) => {
  try {
    await ctx.answerCbQuery();
    
    const session = authSessions.get(ctx.from.id);
    if (!session) {
      return ctx.reply('‚ùå –°–µ—Å—Å–∏—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –∏—Å—Ç–µ–∫–ª–∞. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å —Å–∞–π—Ç–∞.');
    }
    
    // Check subscriptions again
    const groupId = process.env.TELEGRAM_GROUP_ID;
    const chatId = process.env.TELEGRAM_CHAT_ID;
    
    const [isGroupMember, isChatMember] = await Promise.all([
      checkChatMember(ctx, groupId, ctx.from.id),
      checkChatMember(ctx, chatId, ctx.from.id)
    ]);
    
    if (!isGroupMember || !isChatMember) {
      await ctx.reply(
        '‚ùå –í—ã –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã!\n\n' +
        (!isGroupMember ? 'üì¢ –ù—É–∂–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –≥—Ä—É–ø–ø—É\n' : '') +
        (!isChatMember ? 'üí¨ –ù—É–∂–Ω–æ –≤—Å—Ç—É–ø–∏—Ç—å –≤ —á–∞—Ç\n' : '')
      );
    } else {
      await createAuthTokens(ctx, session.phoneNumber, session.sessionId);
    }
  } catch (error) {
    console.error('Check subscription error:', error);
    ctx.reply('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
  }
};

async function createAuthTokens(ctx, phoneNumber, sessionId) {
  try {
    const connection = await pool.getConnection();
    
    try {
      // Check if user already has valid auth tokens for this session
      const [existingTokens] = await connection.execute(
        `SELECT * FROM auth_tokens 
         WHERE session_id = ? AND expires_at > NOW() AND used = FALSE`,
        [sessionId]
      );
      
      if (existingTokens.length > 0) {
        // Tokens already exist, just send the URL
        const urlToken = existingTokens.find(t => t.token_type === 'url');
        if (urlToken) {
          const authUrl = `${process.env.SITE_URL}/auth-callback?session=${sessionId}&token=${urlToken.token}`;
          
          await ctx.reply(
            '‚úÖ –í—ã —É–∂–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω—ã!\n\n' +
            'üåê –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ —á—Ç–æ–±—ã –≤–æ–π—Ç–∏ –Ω–∞ —Å–∞–π—Ç:',
            Markup.inlineKeyboard([
              [Markup.button.url('üöÄ –í–æ–π—Ç–∏ –Ω–∞ —Å–∞–π—Ç DVIZH', authUrl)]
            ])
          );
          
          authSessions.delete(ctx.from.id);
          return;
        }
      }
      
      // Check if user exists
      const [existing] = await connection.execute(
        'SELECT * FROM users WHERE telegram_id = ?',
        [ctx.from.id]
      );
      
      let userId;
      let user;
      
      if (existing.length === 0) {
        // Get user photos if available
        let avatarUrl = null;
        try {
          const photos = await ctx.telegram.getUserProfilePhotos(ctx.from.id, 0, 1);
          if (photos.total_count > 0) {
            const fileId = photos.photos[0][0].file_id;
            const fileUrl = await ctx.telegram.getFileLink(fileId);
            avatarUrl = fileUrl.href;
          }
        } catch (err) {
          console.log('Could not get user avatar:', err);
        }
        
        // Create new user
        const [result] = await connection.execute(
          `INSERT INTO users (telegram_id, username, first_name, last_name, phone_number, avatar_url) 
           VALUES (?, ?, ?, ?, ?, ?)`,
          [
            ctx.from.id,
            ctx.from.username || null,
            ctx.from.first_name,
            ctx.from.last_name || null,
            phoneNumber,
            avatarUrl
          ]
        );
        userId = result.insertId;
      } else {
        user = existing[0];
        userId = user.id;
        
        // Update phone number and user info if needed
        await connection.execute(
          `UPDATE users SET 
           phone_number = COALESCE(phone_number, ?),
           username = ?,
           first_name = ?,
           last_name = ?,
           last_active = CURRENT_TIMESTAMP
           WHERE id = ?`,
          [
            phoneNumber,
            ctx.from.username || null,
            ctx.from.first_name,
            ctx.from.last_name || null,
            userId
          ]
        );
      }
      
      // Create TWO auth tokens - one for immediate auth, one for URL
      const immediateToken = crypto.randomBytes(32).toString('hex');
      const urlToken = crypto.randomBytes(32).toString('hex');
      
      // Store both tokens
      await connection.execute(
        `INSERT INTO auth_tokens (user_id, token, token_type, session_id, expires_at) 
         VALUES 
         (?, ?, 'immediate', ?, DATE_ADD(NOW(), INTERVAL 1 MINUTE)),
         (?, ?, 'url', ?, DATE_ADD(NOW(), INTERVAL 1 MINUTE))`,
        [userId, immediateToken, sessionId, userId, urlToken, sessionId]
      );
      
      // Build auth URL with token
      const authUrl = `${process.env.SITE_URL}/auth-callback?session=${sessionId}&token=${urlToken}`;
      
      // Send success message with URL containing token
      await ctx.reply(
        '‚úÖ –û—Ç–ª–∏—á–Ω–æ! –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ!\n\n' +
        'üåê –í—ã –º–æ–∂–µ—Ç–µ:\n' +
        '1. –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –±—Ä–∞—É–∑–µ—Ä –≥–¥–µ –Ω–∞—á–∞–ª–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é - –æ–Ω–∞ –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏\n' +
        '2. –ò–ª–∏ –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ —á—Ç–æ–±—ã –≤–æ–π—Ç–∏ –ø—Ä—è–º–æ –æ—Ç—Å—é–¥–∞\n\n' +
        '‚è∞ –°—Å—ã–ª–∫–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ 1 –º–∏–Ω—É—Ç—É',
        Markup.inlineKeyboard([
          [Markup.button.url('üöÄ –í–æ–π—Ç–∏ –Ω–∞ —Å–∞–π—Ç DVIZH', authUrl)]
        ])
      );
      
      // Clean up session
      authSessions.delete(ctx.from.id);
    } finally {
      connection.release();
    }
  } catch (error) {
    console.error('Create auth tokens error:', error);
    throw error;
  }
}

async function checkChatMember(ctx, chatId, userId) {
  try {
    const member = await ctx.telegram.getChatMember(chatId, userId);
    return ['creator', 'administrator', 'member'].includes(member.status);
  } catch (error) {
    console.log(`User ${userId} is not in chat ${chatId}`);
    return false;
  }
}

// Clean up old sessions periodically
setInterval(() => {
  const now = Date.now();
  for (const [userId, session] of authSessions.entries()) {
    if (now - session.timestamp > 5 * 60 * 1000) { // 5 minutes
      authSessions.delete(userId);
    }
  }
}, 60000); // Check every minute